!
!  ORSON/LIB/SEQUENCE. Iterators that transform to sequences.
!
!  Copyright © 2018 James B. Moen.
!
!  This  program is free  software: you  can redistribute  it and/or  modify it
!  under the terms  of the GNU General Public License as  published by the Free
!  Software Foundation,  either version 3 of  the License, or  (at your option)
!  any later version.
!
!  This program is distributed in the  hope that it will be useful, but WITHOUT
!  ANY  WARRANTY;  without even  the  implied  warranty  of MERCHANTABILITY  or
!  FITNESS FOR  A PARTICULAR PURPOSE.  See  the GNU General  Public License for
!  more details.
!
!  You should have received a copy of the GNU General Public License along with
!  this program.  If not, see <http://www.gnu.org/licenses/>.
!

!  The iterators defined here don't transform to loops, but rather to sequences
!  of expressions. These may be used to operate on sets of heterogenous objects
!  that aren't easily generated by loops.

(prog

!  Make sure we have the right version.

  Test :− version(''0.14.6.'')

!  INTS. Iterator. Transform to a sequence that applies BODY to a series of INJ
!  constants.
!
!        (for T N in ints(e) do S(N))  ⇒  (for T N in ints(0, e−1, 1) do S(N))
!     (for T N in ints(b, e) do S(N))  ⇒  (for T N in ints(b, e, 1) do S(N))
!  (for T N in ints(b, e, s) do S(N))  ⇒  S(b); S(b + s) ...; S(b + ks); skip
!
!  Choosing constants B, E, and S in an attempt to make a nonterminating series
!  (such as B = 0, E = 1, S = −1) will cause an error.

 ints :−
  (with ignore :− (form (form (inj) obj) obj: skip)
   do (alt
       (form (inj e) foj:
        (if isInt(e)
         then (form (form (inj) obj body) obj:
                ?intFor(body, 0, e − 1, 1))
         else error($e, "constant expected")
              ignore)),
       (form (inj b, inj e) foj:
        (if isInt(b) ∧ isInt(e)
         then (form (form (inj) obj body) obj:
                ?intFor(body, b, e, 1))
         else (if ¬ isInt(b)
               then error($b, "constant expected"))
              (if ¬ isInt(e)
               then error($e, "constant expected"))
              ignore)),
       (form (inj b, inj e, inj s) foj:
        (if isInt(b) ∧ isInt(e) ∧ isInt(s)
         then (form (form (inj) obj body) obj:
                ?intFor(body, b, e, s))
         else (if ¬ isInt(b)
               then error($b, "constant expected"))
              (if ¬ isInt(e)
               then error($e, "constant expected"))
              (if ¬ isInt(s)
               then error($s, "constant expected"))
              ignore))))

!  CDRS. Iterator. Transform to a sequence that applies BODY to every tail of a
!  list L, in order of appearance. Compare TAILS below.

  cdrs :−
   (form (list l) foj:
    (form (form (list) obj body) obj:
      ?listFor(body, l)
      body((:))))

!  ELEMENTS. Iterator. Transform to a sequence that applies BODY to elements of
!  the list L, in order of appearance. If T appears, then L's elements must all
!  coerce to type T. If P appears, then L's elements must all satisfy P.

 elements :−
  (alt
   (form (list l) foj:
    (form (form (obj) obj body) obj:
      ?listFor(
       (form (list l) obj:
        (with e :− car(l)
         do body(e))),
       l))),
   (form (form (obj) bool p, list l) foj:
    (form (form (obj) obj body) obj:
      ?listFor(
       (form (list l) obj:
        (with e :− car(l)
         do (if p(e)
             then body(e)
             else error(l, "unexpected element")))),
       l))),
   (form (type obj t, list l) foj:
    (form (form (t) obj body) obj:
      ?listFor(
       (form (list l) obj:
        (if isCotype(type car(l), t)
         then (with e :− car(l)
               do body(e))
         else error(l, "expression has unexpected type"))),
       l))))

!  TAILS. Iterator. Transform to a sequence that applies BODY to each non empty
!  tail of the list L in order of appearance. Compare CDRS above. If T appears,
!  then the CAR of each tail is required to be of type T. If P appears instead,
!  then the CAR of each tail is required to satisfy P. BODY may also be applied
!  to the CAR of the tail E as well as the tail itself.

 tails :−
  (alt
   (form (list l) foj:
    (alt
     (form (form (list) obj body) obj:
       ?listFor(body, l)),
     (form (form (obj, list) obj body) obj:
       ?listFor(
        (form (list l) obj:
         (with e :− car(l)
          do body(e, l))),
        l)))),
   (form (form (obj) bool p, list l) foj:
    (alt
     (form (form (list) obj body) obj:
       ?listFor(
        (form (list l) obj:
         (with e :− car(l)
          do (if p(e)
              then body(l)
              else error(l, "unexpected element")))),
        l)),
     (form (form (obj, list) obj body) obj:
       ?listFor(
        (form (list l) obj:
         (with e :− car(l)
          do (if p(e)
              then body(e, l)
              else error(l, "unexpected element")))),
        l)))),
   (form (type obj t, list l) foj:
    (alt
     (form (form (list) obj body) obj:
       ?listFor(
        (form (list l) obj:
         (if isSubtype(type car(l), t)
          then body(l)
          else error(l, "expression has unexpected type"))),
        l)),
     (form (form (t, list) obj body) obj:
       ?listFor(
        (form (list l) obj:
         (if isSubtype(type car(l), t)
          then (with e :− car(l)
                do body(e, l))
          else error(l, "expression has unexpected type"))),
        l)))))
)
