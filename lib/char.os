!
!  ORSON/LIB/CHAR. Operations on characters.
!
!  Copyright © 2018 James B. Moen.
!
!  This  program is free  software: you  can redistribute  it and/or  modify it
!  under the terms  of the GNU General Public License as  published by the Free
!  Software Foundation,  either version 3 of  the License, or  (at your option)
!  any later version.
!
!  This program is distributed in the  hope that it will be useful, but WITHOUT
!  ANY  WARRANTY;  without even  the  implied  warranty  of MERCHANTABILITY  or
!  FITNESS FOR  A PARTICULAR PURPOSE.  See  the GNU General  Public License for
!  more details.
!
!  You should have received a copy of the GNU General Public License along with
!  this program.  If not, see <http://www.gnu.org/licenses/>.
!

(prog

!  BY BYTE. If B is the header byte of a UTF−8 char, then dispatch on B to some
!  expression S₁ through S₆. We choose Sⱼ if the char's representation in UTF−8
!  requires j bytes. If B is a continuation byte, then choose expression C, and
!  if B is an illegal byte, then choose I. We execute the chosen expression and
!  return its value.

  byByte :−
   (with m :− mut
    do (form (int b, m s₁, m c, m s₂, m s₃, m s₄, m s₅, m s₆, m i) m:
        (case 16#FF & b
         of 2#00000000, 2#00000001, 2#00000010, 2#00000011,
            2#00000100, 2#00000101, 2#00000110, 2#00000111,
            2#00001000, 2#00001001, 2#00001010, 2#00001011,
            2#00001100, 2#00001101, 2#00001110, 2#00001111,
            2#00010000, 2#00010001, 2#00010010, 2#00010011,
            2#00010100, 2#00010101, 2#00010110, 2#00010111,
            2#00011000, 2#00011001, 2#00011010, 2#00011011,
            2#00011100, 2#00011101, 2#00011110, 2#00011111,
            2#00100000, 2#00100001, 2#00100010, 2#00100011,
            2#00100100, 2#00100101, 2#00100110, 2#00100111,
            2#00101000, 2#00101001, 2#00101010, 2#00101011,
            2#00101100, 2#00101101, 2#00101110, 2#00101111,
            2#00110000, 2#00110001, 2#00110010, 2#00110011,
            2#00110100, 2#00110101, 2#00110110, 2#00110111,
            2#00111000, 2#00111001, 2#00111010, 2#00111011,
            2#00111100, 2#00111101, 2#00111110, 2#00111111,
            2#01000000, 2#01000001, 2#01000010, 2#01000011,
            2#01000100, 2#01000101, 2#01000110, 2#01000111,
            2#01001000, 2#01001001, 2#01001010, 2#01001011,
            2#01001100, 2#01001101, 2#01001110, 2#01001111,
            2#01010000, 2#01010001, 2#01010010, 2#01010011,
            2#01010100, 2#01010101, 2#01010110, 2#01010111,
            2#01011000, 2#01011001, 2#01011010, 2#01011011,
            2#01011100, 2#01011101, 2#01011110, 2#01011111,
            2#01100000, 2#01100001, 2#01100010, 2#01100011,
            2#01100100, 2#01100101, 2#01100110, 2#01100111,
            2#01101000, 2#01101001, 2#01101010, 2#01101011,
            2#01101100, 2#01101101, 2#01101110, 2#01101111,
            2#01110000, 2#01110001, 2#01110010, 2#01110011,
            2#01110100, 2#01110101, 2#01110110, 2#01110111,
            2#01111000, 2#01111001, 2#01111010, 2#01111011,
            2#01111100, 2#01111101, 2#01111110, 2#01111111:
            s₁

            2#10000000, 2#10000001, 2#10000010, 2#10000011,
            2#10000100, 2#10000101, 2#10000110, 2#10000111,
            2#10001000, 2#10001001, 2#10001010, 2#10001011,
            2#10001100, 2#10001101, 2#10001110, 2#10001111,
            2#10010000, 2#10010001, 2#10010010, 2#10010011,
            2#10010100, 2#10010101, 2#10010110, 2#10010111,
            2#10011000, 2#10011001, 2#10011010, 2#10011011,
            2#10011100, 2#10011101, 2#10011110, 2#10011111,
            2#10100000, 2#10100001, 2#10100010, 2#10100011,
            2#10100100, 2#10100101, 2#10100110, 2#10100111,
            2#10101000, 2#10101001, 2#10101010, 2#10101011,
            2#10101100, 2#10101101, 2#10101110, 2#10101111,
            2#10110000, 2#10110001, 2#10110010, 2#10110011,
            2#10110100, 2#10110101, 2#10110110, 2#10110111,
            2#10111000, 2#10111001, 2#10111010, 2#10111011,
            2#10111100, 2#10111101, 2#10111110, 2#10111111:
            c

            2#11000000, 2#11000001, 2#11000010, 2#11000011,
            2#11000100, 2#11000101, 2#11000110, 2#11000111,
            2#11001000, 2#11001001, 2#11001010, 2#11001011,
            2#11001100, 2#11001101, 2#11001110, 2#11001111,
            2#11010000, 2#11010001, 2#11010010, 2#11010011,
            2#11010100, 2#11010101, 2#11010110, 2#11010111,
            2#11011000, 2#11011001, 2#11011010, 2#11011011,
            2#11011100, 2#11011101, 2#11011110, 2#11011111:
            s₂

            2#11100000, 2#11100001, 2#11100010, 2#11100011,
            2#11100100, 2#11100101, 2#11100110, 2#11100111,
            2#11101000, 2#11101001, 2#11101010, 2#11101011,
            2#11101100, 2#11101101, 2#11101110, 2#11101111:
            s₃

            2#11110000, 2#11110001, 2#11110010, 2#11110011,
            2#11110100, 2#11110101, 2#11110110, 2#11110111:
            s₄

            2#11111000, 2#11111001, 2#11111010, 2#11111011:
            s₅

            2#11111100, 2#11111101:
            s₆

            none:
            i)))

!  BY WORD. If W is a UTF-32 char, then dispatch on W to one of the expressions
!  S₁ through S₆. Choose Sⱼ if W's representation in UTF-8 requires j bytes. We
!  execute the chosen expression and return its value.

  byWord :−
   (form (int w, mut s₁, mut s₂, mut s₃, mut s₄, mut s₅, mut s₆) mut:
    (with int w :− (past w)
     do (if w ≤ 16#0000007F
         then s₁
         else if w ≤ 16#000007FF
              then s₂
              else if w ≤ 16#0000FFFF
                   then s₃
                   else if w ≤ 16#001FFFFF
                        then s₄
                        else if w ≤ 16#03FFFFF
                             then s₅
                             else s₆)))

!  IS CONTINUATION. Test if CH is a UTF-8 continuation byte.

  isContinuation :−
   (form (char0 ch) bool:
     ch < −64)

!  LENGTH. Return how many CHAR0s are required to encode CH in UTF-8.

  length :−
   (alt
    (form (char0) int0:
      1),
    (form (char1 ch) int0:
      byWord(ch, 1, 2, 3, 4, 5, 6)))
)
